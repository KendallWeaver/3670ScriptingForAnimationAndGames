// Make controls for joints
// For each selection, a control should be made for each of them. (suffix end of _Ctrl)
    //If that's the case, it sounds like we'll need to use tokenize.
// If statement to compare if there is a selection and if there isn't
    //If there isn't a selection, a control should be made at the origin.
// There should be another function to color the controls
    // This is gonna be the hard part since I don't know how to do this yet.
// Other Functions in place to make the Curvese different shapes

/* First line of code creates a NURBS circle, and the second one makes a square
circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1; objectMoveCommand;
nurbsSquare -c 0 0 0 -nr 0 1 0 -sl1 1 -sl2 1 -sps 1 -d 3 -ch 1 ; objectMoveCommand;

It should be noted that a NURBS square seems to be a group of four separate NURBS, but a circle is just one
*/

// Sept 20: Code works to put controls around OBJECTS. If joints were done, the location of the curbs were not aligned

//IMPORTANT: If you run the script normally, random controls will be made. Try to load the procedures first (select everything and go down to the next "IMPORTANT")

global proc CreateCircleControl(string $inputName)
{
    // Similar Code was used in the last assignment, 
    string $selection[] = `ls -selection -flatten`;    
    string $input[]; //Kind of a buffer; helps parse info to where it needs to go 
    string $numHash;    //Number of Hashtags
    string $sizeOfI;    // used to cast i
    
    float $boxPosition[];    // We've used string arrays for so long; don't forget arrays can be numbers as well
    
    string $location[];
    
    float $xPosition, $yPosition, $zPosition;    // apparently you can initialize multiple variables in one line

    tokenize $inputName "#" $input;
    // input has two arguments; 0 = Arm_ and _Ctrl
    
    // This creates the variable of how many #s there are
    int $numPadding = size($inputName) - (size($input[0]) + size($input[1])); 
    
    if (size($selection) > 0)    // If there was a selection, it will run this code. 
    {
        for($i=0; $i<size($selection); $i++)
        {
            $sizeOfI = $i;
            // Changed i variable to j so the script doesn't mix them together
            // The number of #s will be subtracted by the number of digits i has, thus making room for the actual number
              
            
            // Gets the location of one of the objects in the selected array, learns it's position
            $boxPosition = `xform -q -boundingBox $selection[$i]`;
            
            /* For Testing Purposes
            print($boxPosition);
            */    
            // Set the Center Point 
            $xPosition = ($boxPosition[0]+$boxPosition[3]) / 2;    // Index 0 and 3 is xmin and xmax
            $yPosition = ($boxPosition[1]+$boxPosition[4]) / 2;    // Index 1 and 4 is ymin and xmax
            $zPosition = ($boxPosition[2]+$boxPosition[5]) / 2;    // Index 2 and 5 is zmin and xmax
            
            /* For Testing Purposes
            print($i + "Position in the X is" + $xPosition + "\n");
            print($i + "Position in the X is" + $yPosition + "\n");
            print($i + "Position in the X is" + $zPosition + "\n");
            */
            
            // Taken from Previous assignment to make naming conventions easier
            for ($j=0; $j<($numPadding - size($sizeOfI)); $j++)
            {
               $numHash = ($numHash + "0");
            } 

            string $actualName = $input[0] + ($numHash +$i) + $input[1] ;
            
            circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 2 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name $actualName;
            xform -translation $xPosition $yPosition $zPosition -worldSpace -absolute $actualName;    // Move curve to object
            
            parent $selection[$i] $actualName;    // Makes the nurbCurve the parent of the selected object
            
            $numHash = "";    // Reset the string so it isn't adding several 0s every time
                      
            
        }
    }else    // If there wasn't a selection, it should do this. 
    {
        circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name "_Ctrl"; objectMoveCommand;
    }
    select -cl;
}

global proc CreateSquareControl(string $inputName)
{
    // Similar Code was used in the last assignment, 
    string $selection[] = `ls -selection -flatten`;    
    string $input[]; //Kind of a buffer; helps parse info to where it needs to go 
    string $numHash;    //Number of Hashtags
    string $sizeOfI;    // used to cast i
    
    float $boxPosition[];    // We've used string arrays for so long; don't forget arrays can be numbers as well
    
    string $location[];
    
    float $xPosition, $yPosition, $zPosition;    // apparently you can initialize multiple variables in one line

    tokenize $inputName "#" $input;
    // input has two arguments; 0 = Arm_ and _Ctrl
    
    // This creates the variable of how many #s there are
    int $numPadding = size($inputName) - (size($input[0]) + size($input[1])); 
    
    if (size($selection) > 0)    // If there was a selection, it will run this code. 
    {
        for($i=0; $i<size($selection); $i++)
        {
            $sizeOfI = $i;
            // Changed i variable to j so the script doesn't mix them together
            // The number of #s will be subtracted by the number of digits i has, thus making room for the actual number
              
            
            // Gets the location of one of the objects in the selected array, learns it's position
            $boxPosition = `xform -q -boundingBox $selection[$i]`;
            
            /* For Testing Purposes
            print($boxPosition);
            */    
            // Set the Center Point 
            $xPosition = ($boxPosition[0]+$boxPosition[3]) / 2;    // Index 0 and 3 is xmin and xmax
            $yPosition = ($boxPosition[1]+$boxPosition[4]) / 2;    // Index 1 and 4 is ymin and xmax
            $zPosition = ($boxPosition[2]+$boxPosition[5]) / 2;    // Index 2 and 5 is zmin and xmax
            
            /* For Testing Purposes
            print($i + "Position in the X is" + $xPosition + "\n");
            print($i + "Position in the X is" + $yPosition + "\n");
            print($i + "Position in the X is" + $zPosition + "\n");
            */
            
            // Taken from Previous assignment to make naming conventions easier
            for ($j=0; $j<($numPadding - size($sizeOfI)); $j++)
            {
               $numHash = ($numHash + "0");
            } 

            string $actualName = $input[0] + ($numHash +$i) + $input[1] ;
            
            nurbsSquare -c 0 0 0 -nr 0 1 0 -sl1 3 -sl2 1 -sps 1 -d 3 -ch 1 -name $actualName;
            xform -translation $xPosition $yPosition $zPosition -worldSpace -absolute $actualName;    // Move curve to object
            
            parent $selection[$i] $actualName;    // Makes the nurbCurve the parent of the selected object
            
            $numHash = "";    // Reset the string so it isn't adding several 0s every time
                      
            
        }
    }else    // If there wasn't a selection, it should do this. 
    {
            nurbsSquare -c 0 0 0 -nr 0 1 0 -sl1 3 -sl2 3 -sps 1 -d 3 -ch 1 -name "_Ctrl";
    }
    select -cl;
}

global proc CreateHourglassControl(string $inputName)
{
    // Similar Code was used in the last assignment, 
    string $selection[] = `ls -selection -flatten`;    
    string $input[]; //Kind of a buffer; helps parse info to where it needs to go 
    string $numHash;    //Number of Hashtags
    string $sizeOfI;    // used to cast i
    
    float $boxPosition[];    // We've used string arrays for so long; don't forget arrays can be numbers as well
    
    string $location[];
    
    float $xPosition, $yPosition, $zPosition;    // apparently you can initialize multiple variables in one line

    tokenize $inputName "#" $input;
    // input has two arguments; 0 = Arm_ and _Ctrl
    
    // This creates the variable of how many #s there are
    int $numPadding = size($inputName) - (size($input[0]) + size($input[1])); 
    
    if (size($selection) > 0)    // If there was a selection, it will run this code. 
    {
        for($i=0; $i<size($selection); $i++)
        {
            $sizeOfI = $i;
            // Changed i variable to j so the script doesn't mix them together
            // The number of #s will be subtracted by the number of digits i has, thus making room for the actual number
              
            
            // Gets the location of one of the objects in the selected array, learns it's position
            $boxPosition = `xform -q -boundingBox $selection[$i]`;
            
            /* For Testing Purposes
            print($boxPosition);
            */    
            // Set the Center Point 
            $xPosition = ($boxPosition[0]+$boxPosition[3]) / 2;    // Index 0 and 3 is xmin and xmax
            $yPosition = ($boxPosition[1]+$boxPosition[4]) / 2;    // Index 1 and 4 is ymin and xmax
            $zPosition = ($boxPosition[2]+$boxPosition[5]) / 2;    // Index 2 and 5 is zmin and xmax
            
            /* For Testing Purposes
            print($i + "Position in the X is" + $xPosition + "\n");
            print($i + "Position in the X is" + $yPosition + "\n");
            print($i + "Position in the X is" + $zPosition + "\n");
            */
            
            // Taken from Previous assignment to make naming conventions easier
            for ($j=0; $j<($numPadding - size($sizeOfI)); $j++)
            {
               $numHash = ($numHash + "0");
            } 

            string $actualName = $input[0] + ($numHash +$i) + $input[1] ;
            
            circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 3 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name $actualName;
            // following code picks a point and moves it.
            select -r -sym ($actualName).cv[3] ;
            move -r -smn -3 0 0 ;
            select $actualName;
            xform -translation $xPosition $yPosition $zPosition -worldSpace -absolute $actualName;    // Move curve to object
            
            parent $selection[$i] $actualName;    // Makes the nurbCurve the parent of the selected object
            
            $numHash = "";    // Reset the string so it isn't adding several 0s every time
                      
            
        }
    }else    // If there wasn't a selection, it should do this. 
    {
        circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name "_Ctrl";
        select -r -sym _Ctrl.cv[3] ;
        move -r -smn -1 0 0 ;
    }
    select -cl;
}

global proc CreateSquareControl(string $inputName)
{
    // Similar Code was used in the last assignment, 
    string $selection[] = `ls -selection -flatten`;    
    string $input[]; //Kind of a buffer; helps parse info to where it needs to go 
    string $numHash;    //Number of Hashtags
    string $sizeOfI;    // used to cast i
    
    float $boxPosition[];    // We've used string arrays for so long; don't forget arrays can be numbers as well
    
    string $location[];
    
    float $xPosition, $yPosition, $zPosition;    // apparently you can initialize multiple variables in one line

    tokenize $inputName "#" $input;
    // input has two arguments; 0 = Arm_ and _Ctrl
    
    // This creates the variable of how many #s there are
    int $numPadding = size($inputName) - (size($input[0]) + size($input[1])); 
    
    if (size($selection) > 0)    // If there was a selection, it will run this code. 
    {
        for($i=0; $i<size($selection); $i++)
        {
            $sizeOfI = $i;
            // Changed i variable to j so the script doesn't mix them together
            // The number of #s will be subtracted by the number of digits i has, thus making room for the actual number
              
            
            // Gets the location of one of the objects in the selected array, learns it's position
            $boxPosition = `xform -q -boundingBox $selection[$i]`;
            
            /* For Testing Purposes
            print($boxPosition);
            */    
            // Set the Center Point 
            $xPosition = ($boxPosition[0]+$boxPosition[3]) / 2;    // Index 0 and 3 is xmin and xmax
            $yPosition = ($boxPosition[1]+$boxPosition[4]) / 2;    // Index 1 and 4 is ymin and xmax
            $zPosition = ($boxPosition[2]+$boxPosition[5]) / 2;    // Index 2 and 5 is zmin and xmax
            
            /* For Testing Purposes
            print($i + "Position in the X is" + $xPosition + "\n");
            print($i + "Position in the X is" + $yPosition + "\n");
            print($i + "Position in the X is" + $zPosition + "\n");
            */
            
            // Taken from Previous assignment to make naming conventions easier
            for ($j=0; $j<($numPadding - size($sizeOfI)); $j++)
            {
               $numHash = ($numHash + "0");
            } 

            string $actualName = $input[0] + ($numHash +$i) + $input[1] ;
            
            //Make a Nurbs Circle
            circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 3 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name $actualName;
            //Moving the Points so it's more of a square shape
            select -r -sym ($actualName).cv[7] ;
            move -r -smn -1 0 0 ;
            select -r -sym ($actualName).cv[5];
            select -tgl -sym ($actualName).cv[1];
            scale -r -p 0cm 0cm 0cm 1 1 0.652316 ;
            select -cl;

            
            //Once the points are moved, we select the control so it can be moved in the right spot
            select $actualName;
            xform -translation $xPosition $yPosition $zPosition -worldSpace -absolute $actualName;    // Move curve to object
            
            parent $selection[$i] $actualName;    // Makes the nurbCurve the parent of the selected object
            
            $numHash = "";    // Reset the string so it isn't adding several 0s every time
                      
            
        }
    }else    // If there wasn't a selection, it should do this. 
    {
             circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 3 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1 -name "_Ctrl";
             //Moving the Points so it's more of a square shape
            select -r -sym _Ctrl.cv[5];
            select -tgl -sym _Ctrl.cv[1];
            scale -r -p 0cm 0cm 0cm 1 1 0.652316 ;
            select -r -sym _Ctrl.cv[7] ;
            move -r -smn -1 0 0 ;
    }
    select -cl;
}

global proc ColorControls(int $colorIndex)
{
    string $selectedControls[] = `ls -sl`;
    /*For Testing What's in the Selected Array
    print ($selectedControls);
    */
    for ($select in $selectedControls)
    {
        string $controlName = $select;
        ChangeColors($controlName, $colorIndex);
    }
}

global proc ChangeColors(string $controlName, int $colorIndex)
{
    // This code will actually change the colors. Derived from the Lecture notes on Sept 25    
    //define string array for the shapes
    string $shapes[];
    
    // find the shape node[s] of $controlName (we're doing it to the shape, not the object)
    $shapes = `listRelatives -shapes $controlName`;
    
    // We need to override on $shape
    for ($shape in $shapes)
    {
        //We're gonna check to make sure the shape is actually a curve
        if (`nodeType $shape` == "nurbsCurve")
        {
            // $shape is a string
            setAttr ($shape + ".overrideEnabled") 1 ;    //you have to list the object.Attribute
            
            // We need to set $shape color to $color
            setAttr ($shape + ".overrideColor") $colorIndex;
        }else        
        {
            print("Not A Control");
        }
    }   

}

// IMPORTANT: Load the previous procedures first. 

CreateCircleControl("Arm_##_Ctrl");    // Make CIRCLE controls
CreateSquareControl("Arm_##_Ctrl");    // Make SQUARE controls
CreateHourglassControl("Arm_##_Ctrl");    //Make HOURGLASS controls

ColorControls(13);

